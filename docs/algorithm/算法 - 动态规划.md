# 动态规划

当计算某个问题的解时，可以通过已经计算过的子问题的解来推导出该问题的解，这种自底向上的思路被称为动态规划。
动态规划常用来求解最优化问题，如求解最长上升子序列、背包问题等。

通常来说，动态规划问题有三个重要的特征：

1. 重叠子问题：即问题的解可以通过计算子问题的解来得到。
2. 最优子结构：即问题的最优解可以通过计算子问题的最优解来得到。
3. 无后效性：即对于某个状态，我们只需要它之前的状态就可以计算出它的后续状态，不需要考虑之后的状态。

动态规划分为自顶向下的记忆化搜索和自底向上的动态规划，两种方法都可以求解动态规划问题。

自顶向下的记忆化搜索是一种自上而下的过程，它首先检查是否已经计算过问题的解，如果计算过，就返回这个解。
如果没有计算过，它就递归地计算问题的解，并将其保存在一个数组中，以便后续的访问。
这种方式通常用于解决子问题相互独立的情况。

自底向上的动态规划是一种自下而上的过程，它从最简单的子问题开始，逐渐推导出复杂的问题，直至得到原问题的解。
这种方式通常用于解决子问题相互依赖的情况。

动态规划的时间复杂度通常是 `O(n^2)`，其中 `n` 表示问题的规模。但是，有些问题可以使用其他方法进行优化，以达到更好的时间复杂度。

比如我们可以看一个很经典的背包问题，假设有一个背包，它能承受的重量为 `W`，现在有 `n` 个物品，每个物品有一个重量 `w[i]` 和一个价值 `v[i]`，我们的目标是将某些物品装入背包中，使得在不超过背包重量的前提下，背包所装载物品的总价值最大化。

这个问题可以用动态规划来解决，它的核心是 “状态定义” 和 “状态转移方程”。
我们可以定义 `dp[i][j]` 表示在前 `i` 个物品中，能够装入一个容量为j的背包中的物品的最大价值。
那么就可以写出状态转移方程了：

`dp[i][j] = max(dp[i-1][j],dp[i-1][j-w[i]]+v[i])`

其中 `dp[i-1][j]` 表示不选择第i个物品，`dp[i-1][j-w[i]]+v[i]` 表示选择第i个物品。
我们取这两者的最大值就是 `dp[i][j]` 的状态转移方程。

这个问题的时间复杂度是 `O(nW)`，其中n为物品数，W为背包容量。
当物品和背包容量增加时，时间复杂度将更加显著，但在实际应用中，我们可以对其进行一些优化，例如使用一维数组来存储状态，或使用贪心算法来优化等。
