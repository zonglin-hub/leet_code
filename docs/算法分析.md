# 算法分析

时间复杂度和空间复杂度都是一种衡量算法性能的指标。时间复杂度衡量的是算法的执行时间，空间复杂度衡量的是算法所需的存储空间。它们的分级规则如下：

时间复杂度：

1. 常数级别：时间复杂度为 O(1)。例如，一次只执行一条语句的赋值操作，不论数据规模的大小，执行时间都相同，时间复杂度为 O(1)。
2. 对数级别：时间复杂度为 O(logn)。例如，二分查找算法。
3. 线性级别：时间复杂度为 O(n)。例如，数组遍历算法。
4. 线性对数级别：时间复杂度为 O(nlogn)。例如，快速排序算法。
5. 平方级别：时间复杂度为 O(n^2)。例如，冒泡排序算法。
6. 立方级别：时间复杂度为 O(n^3)。例如，矩阵乘法算法。
7. 指数级别：时间复杂度为 O(2^n)。例如，爬楼梯算法中的递归实现。

空间复杂度：

1. 常数级别：空间复杂度为 O(1)。例如，只需一个变量的算法。
2. 线性级别：空间复杂度为 O(n)。例如，需要一个长度为 n 的数组的算法。
3. 平方级别：空间复杂度为 O(n^2)。例如，需要一个 n×n 的二维数组的算法。

一般来说，时间复杂度越小的算法执行时间越短，空间复杂度越小的算法所需的存储空间越小。因此，在算法设计时，需要考虑如何尽可能地优化时间复杂度和空间复杂度。

示例：

```rust
pub fn max_profit_1(prices: Vec<i32>) -> i32 {
    let (mut res, mut min) = (0, prices[0]);
    for i in prices {
        match i - min {
            t if t > res => res = t,
            t if t < 0 => min = i,
            _ => (),
        }
    }
    res
}
```

看时间复杂度，需要分析每个操作的时间复杂度，然后加起来。这段代码中主要的操作是遍历 `prices` 向量，然后进行了一些常数级别的计算，其时间复杂度为 $O(n)$，其中 $n$ 是 `prices` 向量的长度。

看空间复杂度，需要分析程序运行过程中所占用的内存空间，然后计算。这段代码中只定义了两个变量 `res` 和 `min`，因此其空间复杂度为 $O(1)$，即常数级别的空间复杂度。

空间复杂度是算法在运行过程中，所需的存储空间的大小。具体的计算方法是：分析算法中使用的变量、数据结构、辅助空间等在运行过程中所占用的空间大小，并且将其转化为算法输入规模（数据规模）的函数。通常来说，空间复杂度也是针对最坏情况下的复杂度。

换句话说，空间复杂度可以看作算法需要额外开辟的空间大小。在这个例子中，程序只定义了两个变量 `res` 和 `min`，不会随着输入规模的增大而增大，因此空间复杂度为常数级别的 $O(1)$。

## 参考文档

- [A book about Rust Data Structures and Algorithms.](https://github.com/QMHTMY/RustBook)
