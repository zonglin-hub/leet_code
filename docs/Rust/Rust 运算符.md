# 与运算符

与运算符是 `&` 符号。它的作用是对两个二进制数的每一位进行与运算，即如果两个对应位都为 1，则该位结果为 1；否则为 0。例如，对于二进制数 0b1101 和 0b1010，它们进行与运算的结果为 0b1000。在 Rust 中，与运算符也可以用于布尔类型的值进行逻辑运算，其中 true 表示 1，false 表示 0。

## 判断一个整数是否为 2 的幂次方的

这段代码是用来判断一个整数是否为 2 的幂次方的。我们知道，2 的幂次方在二进制中的表现形式是只有一个 1，其余全是 0。例如，2 的 3 次方是 8，其二进制表示为 0b1000。而 9 就不是 2 的幂次方，因为它的二进制表示为 0b1001，其中不只有一个 1。

而这段代码的实现方法是，首先判断这个数是否是正整数，如果是负数或者 0，那么显然不是 2 的幂次方。接下来，我们用 n 和 n - 1 做位运算，如果结果为 0，那么说明 n 中只有一个 1，其余全是 0，满足 2 的幂次方的特点，返回 true。否则，返回 false。

具体来说，如果一个数是 2 的幂次方，那么它的二进制表示形如 1000、10000、100000 这样的形式，即只有一位是 1，其余位都是 0。而将这个数减去 1，会使得原来那个二进制位由 1 变成 0，后面所有的 0 位都变成 1。例如，对于数 8，其二进制表示为 1000，将它减去 1 得到 0111。然后，把这两个数做位与运算，得到结果 0，这说明它们二进制位上只有一个 1。而对于不是 2 的幂次方的数，它们的二进制表示中肯定会有多个 1，减去 1 后，其中的某一位上的 1 会变成 0，导致位与的结果不为 0。

因此，这段代码的实现方法非常巧妙和高效，只需要进行一次判断和一次位运算就能得到答案。

案例：

当 n = 4 时，4 的二进制表示为 0b100，n - 1 的二进制表示为 0b011，它们进行与运算得到的结果为 0，因此 n 是 2 的幂次方。

当 n = 5 时，5 的二进制表示为 0b101，n - 1 的二进制表示为 0b100，它们进行与运算得到的结果为 0b100，不为 0，因此 n 不是 2 的幂次方。

当 n = 16 时，16 的二进制表示为 0b10000，n - 1 的二进制表示为 0b1111，它们进行与运算得到的结果为 0，因此 n 是 2 的幂次方。

```rust
impl Solution {
    pub fn is_power_of_two(n: i32) -> bool {
        n > 0 && n & (n - 1) == 0
    }
}
```
